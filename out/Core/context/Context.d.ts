import Human from "game/entity/Human";
import NPC from "game/entity/npc/NPC";
import type Player from "game/entity/player/Player";
import type { ItemType } from "game/item/IItem";
import type Item from "game/item/Item";
import type { IVector3 } from "utilities/math/IVector";
import type { IBase, IInventoryItems, IUtilities } from "../ITars";
import { ITarsOptions } from "../ITarsOptions";
import ContextState from "./ContextState";
import type { IContext } from "./IContext";
export default class Context implements IContext {
    readonly human: Human;
    readonly base: IBase;
    readonly inventory: IInventoryItems;
    readonly utilities: IUtilities;
    readonly options: Readonly<ITarsOptions>;
    state: ContextState;
    readonly calculatingDifficulty: boolean;
    private initialState?;
    private changes;
    constructor(human: Human, base: IBase, inventory: IInventoryItems, utilities: IUtilities, options: Readonly<ITarsOptions>, state?: ContextState, calculatingDifficulty?: boolean, initialState?: ContextState | undefined);
    get island(): import("../../../node_modules/@wayward/types/definitions/game/game/island/Island").default;
    get actionExecutor(): Player | NPC;
    toString(): string;
    clone(calculatingDifficulty?: boolean, increaseDepth?: boolean): Context;
    merge(state: ContextState): void;
    watchForChanges(): ContextState;
    unwatch(): void;
    isReservedItem(item: Item): boolean;
    isSoftReservedItem(item: Item): boolean;
    isHardReservedItem(item: Item): boolean;
    isReservedItemType(itemType: ItemType): boolean;
    getData<T = any>(type: string): T | undefined;
    getDataOrDefault<T = any>(type: string, defaultValue: T): T;
    setData<T = any>(type: string, value: T | undefined): void;
    addSoftReservedItems(...items: Item[]): void;
    addHardReservedItems(...items: Item[]): void;
    addProvidedItems(itemTypes: ItemType[]): void;
    tryUseProvidedItems(itemType: ItemType): boolean;
    setInitialState(state?: ContextState): void;
    reset(): void;
    getHashCode(): string;
    getFilteredHashCode(allowedItemTypes: Set<ItemType>): string;
    markShouldIncludeHashCode(): void;
    isPlausible(difficulty: number, requireMinimumAcceptedDifficulty?: boolean): boolean;
    getPosition(): IVector3;
}
